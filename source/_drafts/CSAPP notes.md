---
title: 深入理解计算机系统笔记
date: 2018-10-24
tags:
categories: notes
---



## 计算机系统漫游



### 信息就是位+上下文

所有的信息，都是由一系列比特位组成，区分这些不同数据对象的唯一方法是读到这些信息时的上下文。



### C 编译步骤
- 预处理
- 编译成汇编
- 汇编成“可重定位目标程序”
- 链接合并



### 总线
计算机组件间规范化的交换数据的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。

计算机位数通常指总线的宽度，是指一次能传输的数据的位数，即**字长**。



### I/O 设备
鼠标、键盘、显示器、磁盘。
I/O 硬件通过适配器或控制器连接 I/O 总线。



### 存储设备层次结构
- 寄存器
- L1、L2、L3...缓存
- 主存（内存）
- 磁盘



### 操作系统基本功能
- 防止硬件被程序滥用
- 提供简单一直的借口来控制不同的硬件设备



#### 进程

**进程**是操作系统对一个**正在运行程序**的一种抽象。

操作系统在多个进程中的切换叫做**上下文切换**。

 

#### 内核
- 进程
- 内核



## 信息的表示和处理

三种重要的数字表示：

- **无符号**编码给予传统二进制表示法，标识大于或等于零的数字。
- **补码**编码表示有符号整数为正或为负。
- **浮点数**编码是表示实数的科学记数法以2为基数的版本。



计算机用有**限数量的位**来对数字编码，但当结果超出范围而不能表示时，就会**溢出**。

整数的表示是**精确**的，浮点数的表示是**近似**的。



### 信息存储

通常使用**8位**的块或者**字节（byte）**，作为**最小可寻址**的内存单位。

机器级程序将内存视为一个字节数组，称为**虚拟内存**；内存中的每一个字节都有一个唯一标识，称为**地址**；所有地址的集合称为**虚拟地址空间**。



#### 十六进制表示法

在表示字节时，二进制太冗长，十进制需要转化，通常使用十六进制来表示。一位十六进制数可以转转为四位二进制数，两位十六进制数可以表示一个**字节**的所有位。



#### 字数据大小

每台计算机都有一个**字长（word size）**，指明指针数据的标称大小。

因为虚拟地址是以一个字长来编码的，所以字长决定系统虚拟地址空间的最大大小。



#### 寻址和字节顺序

对于跨多字节的程序对象，有两个规则：

1. 这个对象的**地址**是什么
   - 通常，多字节对象被存储为连续的字节序列，**对象的地址为所使用字节中最小的地址**。
2. 如何**排列**这些字节
   - 最低有效字节在最前面的方式，称为**小端法**。
   - 最高有效字节在最前面的方式，称为**大端法**。



#### 表示字符串

 C 语言中字符串被编码为一个以 **null** （值为0）字符结尾的字符数组。



#### 表示代码

不同机器类型使用不同且不兼容的指令和编码方式，即使相同的进程，运行在不同的操作系统上也会有不同的编码规则。



#### 布尔代数

通过将逻辑值 True 和 False 编码为二进制 1 和 0，能设计出一种代数，用于研究逻辑推理的基本原则。

- ~ 运算对应逻辑运算 NOT
- & 运算对应逻辑运算 AND
- | 运算对应逻辑运算 OR
- ^ 运算对应逻辑运算 异或



#### C 语言中的位级运算

C 语言支持按位布尔运算，并能运用到任何”整型“的数据类型上。



#### C 语言中的逻辑运算

C 语言提供 `||`、`&&` 和 `!`三种逻辑运算符。

逻辑运算认为所有非零的参数都是表示 `True`，而参数 0 表示 `False`，并返回 1 或 0。



#### C 语言中的移位运算

逻辑左移 `k` 位，会丢弃最高的 `k` 位，并在右端补 `k` 个 `0`。

逻辑右移支持两种形式：

1. 逻辑右移 k 位， 会丢弃最低的 `k` 位，并在左端补 `k` 个 `0`。
2. 算数右移 k 位，会丢弃最低的 `k` 位，并在右端补 `k` 个 `最高有效位的值`。



### 整数表示

用位来表示编码整数有两种不同的方式：**无符号编码**、**补码编码**。



#### 整型数据类型

整型数据类型表示有限范围内的整数。

不同整型表示数值的范围不同，同时为这些类型所分配的字节数根据程序编译为32或64位也有所不同。

整型中负数的范围比正数的范围大1。（典型取值范围）

C 语言标准中定义了每种类型的最小取值范围，并要求正数与负数的取值范围是对称的。（标准定义）



#### 无符号数的编码

对于有 $w$ 位的整数数据类型，整个位向量可表示为 $\vec{x}$ ，每一位可表示为 $[x_{w-1}, x_{w-2},  ..., x_{0}]$。

每一位 $x_i$的取值为 0 或 1，$x_i$为 1 时表示 $2^i$ 为数值的一部分。

用函数 $B2U_w$表示为：$B2U_w(\vec{x}) = \sum^{w-1}_{i=0} x_i2^i$。



#### 补码编码

补码编码将最高有效位解释为负权，也称为**符号位**。

用函数$B2T_w(\vec{x})$表示为：$B2T_w(\vec{x}) = -x_{w-1}2^{w-1} + \sum^{w-2}_{i=0} x_i2^i$。



#### 有符号数和无符号数之间的转换

类型转换的结果保持位值不变，只是改变了解释这些位的方式。

用数学化的形式表示，定义函数 $U2B_w$ 、$T2B_w$，将数值映射为无符号数和补码形式的表示。

函数 $T2U_w$ 定义为 $T2U_w(x) = B2U_w(T2B_w(x))$ ，表示补码到无符号数的转换。

函数 $U2T_w$ 定义为 $U2T_w(x) = B2T_w(U2B_w(x))$ ，表示无符号数到补码到转换。



#### C 语言中的有符号数与无符号数

C语言标准没有指定有符号数的表示，通常机器都是使用补码，并默认大多数数字是有符号的。

创建一个无符号常量，需要加上  `U`  或 `u` 后缀。

C语言允许在各种不同的数字数据类型之间做强制类型转换，并允许有符号数与无符号数进行运算。

当有符号数与无符号数进行计算时，会把有符号数转为无符号数，并认为是非负的。这样在进行 `<`、`>`关系运算时会表现出一些差异，如： `-1 < 0u` 。



#### 扩展一个数字的位表示

将一个无符号数转换为一个更大的数据类型时，在位表示的开头补 `0` 即可。

将补码表示的数字转换为一个更大的数据类型，需要执行一个符号扩展，即在位表示的开头补 `1`即可。



#### 截断数字 TODO

将一个 $w$ 位的数 $\vec{x}=[x_{w-1}, x_{w-2}, ..., x_0]$ 截断为一个 $k$ 位数字时，会丢弃高的 $w-k$ 位，得到一个位向量 $\vec{x}' =[x_{k-1}, x_{k-2}, ..., x_0]$。



截断无符号数，





### 整数运算 TODO



####  无符号加法

当两个 $w$ 位无符号数相加时，结果可能需要 $w+1$ 位才能表示，然后把 $x+y$ 的和截断位 $w$ 位得到结果，再把这个结果看作是一个无符号数，如果要完整的表示算数运算的结果，则不能对字长做任何限制。

这可以被视为一种形式的摸运算，对于 $x+y$ 的位表示，丢弃权重大于 $2^{w-1}$ 的位就可以计算出和模 $2^w$。

正常情况下 $x+y$ 的值保持不变，**溢出**的情况下值为该和数**减去 $2^w$** 。



#### 补码加法

给定在范围内 $-2^{w-1} \leq x, y \leq 2^{w-1} -1$ 之内的整数值 $x$ 和 $y$ ，他们的和就在范围 $-2^w \leq x + y \leq 2^w - 2$ 之内，想要准确表示，可能需要 $w + 1$ 位，同样通过阶段到 $w$ 位来避免字长膨胀。

当 $x + y$ 当和超过 $TMax_w$ 时，发生**正溢出**，截断的结果是从和数中**减去 $2^w$**。

当 $x + y$ 当和超过 $TMin_w$ 时，发生**负溢出**，截断的结果是从和数中**加上 $2^w$**。



#### 补码的非

对于 $TMin_w + TMin_w = -2^{w-1} + (-2^{w-1}) = -2^w $ ，将导致负溢出，结果为 0 。

对于 $w$ 位的补码， $TMin_2$ 是自己的加法的逆，对于其他任何数值 $x$ 都有 $-x$ 作为其加法的逆。



### 浮点数 TODO



## 程序的机器级表示

