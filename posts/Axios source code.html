<!DOCTYPE html><html lang="en"><title>Axios 源码学习 - OS</title><meta charset="utf-8"><meta name="description"content="Axios 源码学习"><meta name="keywords"><meta name="subtitle"content="Code &amp; Life"><meta name="author"content="zowiegong"><meta name="language"content="zh-CN"><meta name="timezone"content="Asia/Shanghai"><meta name="viewport"content="width=device-width,initial-scale=1"><link href="/manifest.json"rel="manifest"><link href="/atom.xml"rel="alternate"type="application/atom+xml"><link href="/images/favicon.ico"rel="shortcut icon"type="image/x-icon"><link href="/css/style.css"rel="stylesheet"><link href="/css/post.css"rel="stylesheet"><meta name="generator"content="Hexo 4.2.0"><header id="header-container"><h1 id="blog-title"><a href="/">OS</a></h1><nav><ul class="menu-list"><li class="menu-list-item"><a href="/categories"class="menu-name">categories</a><li class="menu-list-item"><a href="/tags"class="menu-name">tags</a><li class="menu-list-item"><a href="/about"class="menu-name">about</a></ul></nav></header><article class="main"><h1 id="post-title">Axios 源码学习</h1><div class="post-info"><time class="post-date">2018-11-25</time><ul class="tag-list"><li class="tag-item"><a href="/tags/source-code/"class="tag-name">#source code</a></ul></div><section class="markdown-body"><h2><a href="#main-file"class="anchor"aria-hidden="true"id="user-content-main-file"><span class="octicon octicon-link"aria-hidden="true"></span></a>Main file</h2><p>通过<code>package.json</code>找到入口文件<code>lib/axios.js</code>。<p>这里导出了<code>Axios</code>的实例，并在实例上挂载了<code>create</code>、<code>Cancel</code>、<code>CancelToken</code>、<code>isCancel</code>、<code>all</code>、<code>spread</code>等属性方法以及<code>Axios</code>构造函数。<h2><a href="#axios-class"class="anchor"aria-hidden="true"id="user-content-axios-class"><span class="octicon octicon-link"aria-hidden="true"></span></a>Axios class</h2><p>从入口文件顶部可以看到 Axios 类的构造函数位于<code>core/Axios.js</code>。<p>构造函数内部定义两个实例属性：<code>defaults</code>、<code>interceptors</code>。<p><code>defaults</code>为传入构造函数的参数。<p><code>interceptors</code>的两个属性分别是<code>request</code>与<code>response</code>，默认值都是<code>InterceptorManager</code>类的实例。<p>在<code>Axios</code>原型上定义有<code>request</code>、<code>getUri</code>两个方法。<p>在使用 axios 时通常有两种方式发起请求：<ol><li><code>axios.request(config)</code>或<code>axios.request(url[, config])</code><li><code>axios[method](url, config)</code>或<code>axios[method](url, data, config)</code></ol><p>这里在<code>Axios</code>内部将<code>delete</code>、<code>get</code>、<code>head</code>、<code>options</code>四种请求方式封装成不需要<code>data</code>参数形式，<p>将<code>post</code>、<code>put</code>、<code>patch</code>三种请求方式封装成需要<code>data</code>参数形式，<p>并最终调用<code>Axios.request</code>方法 Dispatch request。<h3><a href="#interceptormanager"class="anchor"aria-hidden="true"id="user-content-interceptormanager"><span class="octicon octicon-link"aria-hidden="true"></span></a>InterceptorManager</h3><p><code>InterceptorManager</code>类用管理拦截器。<p>实例属性<code>handlers</code>保存所有定义的拦截器。<p><code>interceptorManager.use</code>添加拦截器到<code>handlers</code>数组，并返回其索引。<p><code>interceptorManager.eject</code>通过 id (索引)移除拦截器。<p><code>interceptorManager.foeEach</code>遍历所有拦截器。<h3><a href="#axiosrequest"class="anchor"aria-hidden="true"id="user-content-axiosrequest"><span class="octicon octicon-link"aria-hidden="true"></span></a>axios.request</h3><p><code>axios.request</code>用来调度拦截器与控制请求发送。<p>在<code>request</code>方法内部首先对参数进行了兼容性处理，兼容<code>axios.request(config)</code>与<code>axios.request(url[, config])</code>两种形式的调用。<p>再将参数<code>config</code>与<code>this.defaults</code>属性，也就是实例化<code>Axios</code>类时传入的默认配置进行合并。<p>下面是<code>request</code>方法核心代码：<div class="highlight highlight-source-js"><pre>
  <span class="pl-k">var</span> chain <span class="pl-k">=</span> [dispatchRequest, <span class="pl-c1">undefined</span>];
  <span class="pl-k">var</span> promise <span class="pl-k">=</span> <span class="pl-c1">Promise</span>.<span class="pl-c1">resolve</span>(config);

  <span class="pl-c1">this</span>.<span class="pl-smi">interceptors</span>.<span class="pl-smi">request</span>.<span class="pl-c1">forEach</span>(<span class="pl-k">function</span> <span class="pl-en">unshiftRequestInterceptors</span>(<span class="pl-smi">interceptor</span>) {
    <span class="pl-smi">chain</span>.<span class="pl-c1">unshift</span>(<span class="pl-smi">interceptor</span>.<span class="pl-smi">fulfilled</span>, <span class="pl-smi">interceptor</span>.<span class="pl-smi">rejected</span>);
  });

  <span class="pl-c1">this</span>.<span class="pl-smi">interceptors</span>.<span class="pl-smi">response</span>.<span class="pl-c1">forEach</span>(<span class="pl-k">function</span> <span class="pl-en">pushResponseInterceptors</span>(<span class="pl-smi">interceptor</span>) {
    <span class="pl-smi">chain</span>.<span class="pl-c1">push</span>(<span class="pl-smi">interceptor</span>.<span class="pl-smi">fulfilled</span>, <span class="pl-smi">interceptor</span>.<span class="pl-smi">rejected</span>);
  });

  <span class="pl-k">while</span> (<span class="pl-smi">chain</span>.<span class="pl-c1">length</span>) {
    promise <span class="pl-k">=</span> <span class="pl-smi">promise</span>.<span class="pl-c1">then</span>(<span class="pl-smi">chain</span>.<span class="pl-c1">shift</span>(), <span class="pl-smi">chain</span>.<span class="pl-c1">shift</span>());
  }</pre></div><p><code>chain</code>为待执行队列，默认有一个<code>dispatchRequest</code>用来发送请求。<p><code>promise</code>是一个<code>resolved</code>的<code>Promise</code>对象，默认返回<code>config</code>。<p>随后遍历所有拦截器，并将 request interceptors handlers 添加至执行队列头部，将 response interceptors handlers 添加到执行队列尾部。<p>最后遍历<code>chain</code>队列，执行 request 拦截器时<code>promise</code>变量中默认 resolve 的<code>config</code>对象被传入拦截器，最先添加的拦截器最后执行，拦截器第二个回调 catch 先执行拦截器中的错误，直到被<code>config</code>传入<code>dispatchRequest</code>。请求响应 response 依次传入 response 拦截器，执行顺序与 request 拦截器相反。<h2><a href="#dispatchrequest"class="anchor"aria-hidden="true"id="user-content-dispatchrequest"><span class="octicon octicon-link"aria-hidden="true"></span></a>dispatchRequest</h2><p>Axios 类用来调度拦截器与<code>dispatchRequest</code>方法，实际的请求则是由<code>dispatchRequest</code>处理请求<code>config</code>对象后适配不同平台然后进行发送的。<p><code>dispatchRequest</code>主要是对<code>config</code>对象进行一下处理：<ul><li>处理请求<code>config.url</code>，优先使用绝对路径<li>设置默认请求头为<code>{}</code><li>格式化 request data<li>处理默认<code>config.headers</code><li>调用适配后的方法发送请求<li>在最终发送请求的 Promise 回来后对 response 格式化，并 catch 错误</ul><h2><a href="#adapter"class="anchor"aria-hidden="true"id="user-content-adapter"><span class="octicon octicon-link"aria-hidden="true"></span></a>adapter</h2><p>axios 根据<code>process</code>判断是否为 node.js 环境，通过<a href="https://zh.wikipedia.org/zh-hans/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"target="_blank"rel="nofollow noopener">适配器模式</a>兼容 node.js 与浏览器环境。<h3><a href="#xhr"class="anchor"aria-hidden="true"id="user-content-xhr"><span class="octicon octicon-link"aria-hidden="true"></span></a>XHR</h3><p><code>lib/adapters/xhr.js</code>的<code>xhrAdapter</code>方法适配浏览器环境。<p>接受一个<code>config</code>对象，并返回一个<code>Promise</code>对象。<p>请求最终通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"target="_blank"rel="nofollow noopener"><code>XMLHttpRequest</code>类</a>实例<code>request</code>发送，方法内部通过<code>config</code>对象配置<code>request</code>。<p>调用<code>request.open</code>前做了如下判断：<ul><li>判断 request data 是否为 formData 格式<ul><li>如果是，删除<code>Content-Type</code>头，浏览器会自动配置</ul><li>判断是否配置<code>config.auth</code>HTTP basic authentication（<a href="https://zh.wikipedia.org/wiki/HTTP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81"target="_blank"rel="nofollow noopener">基本认证</a>）<ul><li>如果是，将认证信息 Base64 编码在<code>Authorization</code>头内</ul></ul><p>调用 request.open 后配置 XHR Event handler:<ul><li>readystatechange 事件<ul><li>过滤未完成的请求<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState"target="_blank"rel="nofollow noopener"><code>readyState</code></a>不为<code>4</code><li>处理<code>file:</code>协议请求成功<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status"target="_blank"rel="nofollow noopener"><code>status</code></a>为<code>0</code><li>包装<code>response</code><li>通过<code>settle</code>方法 resolev promise</ul><li>abort 事件<ul><li>处理浏览器终止请求，抛出错误</ul><li>error 事件<ul><li>抛出错误</ul><li>timeout 事件<ul><li>抛出错误</ul></ul><p>继续根据<code>config</code>对象配置<code>request</code>：<ul><li>添加 xsfr 头<li>添加其余请求头<li>配置<code>request.withCredentials</code>属性<li>配置<code>request.responseType</code>属性<li>配置 progress 事件<li>配置 upload 事件<li>配置 abort 后的处理</ul><p>最后调用<code>request.send</code>发起 XHR 请求。</section></article><footer class="footer-container"><section>Copyright &copy; 2020&nbsp;<a href="mailto:zowiegong@gmail.com">zowiegong</a>&nbsp;Powered by&nbsp;<a href="https://github.com/hexojs/hexo"target="_blank"rel="noopener noreferrer">Hexo</a>&nbsp;Theme by&nbsp;<a href="https://github.com/zowiegong/hexo-theme-os"target="_blank"rel="noopener noreferrer">OS.</a><br><a href="https://github.com/zowiegong/hexo-blog/edit/master/source/_posts/Axios source code.md"target="_blank">Edit source file</a></section></footer><div class="hover-pointer"id="scroll-to-top-container"><svg class="hover-fill"height="3rem "id="scroll-to-top-btn"version="1.1"viewBox="0 0 1024 1024"width="3rem"><path d="M825.568 555.328l-287.392-289.28C531.808 259.648 523.488 256.576 515.2 256.64 514.08 256.544 513.12 256 512 256c-4.672 0-9.024 1.088-13.024 2.88-4.032 1.536-7.872 3.872-11.136 7.136l-259.328 258.88c-12.512 12.48-12.544 32.736-0.032 45.248 6.24 6.272 14.432 9.408 22.656 9.408 8.192 0 16.352-3.136 22.624-9.344L480 364.288 480 928c0 17.696 14.336 32 32 32s32-14.304 32-32L544 362.72l236.192 237.728c6.24 6.272 14.496 9.44 22.688 9.44s16.32-3.104 22.56-9.312C838.016 588.128 838.048 567.84 825.568 555.328z"p-id="1100"></path><path d="M864 192 160 192C142.336 192 128 177.664 128 160s14.336-32 32-32l704 0c17.696 0 32 14.336 32 32S881.696 192 864 192z"p-id="1101"></path></svg></div><script>let pluginsConfig = JSON.parse('{"googleAnalytics":"UA-121105508-1","scrollToTop":true,"scrollSmooth":false,"comments":{"enable":true,"repo":"zowiegong/hexo-blog"}}')</script><script>pluginsConfig.comments.enable = true</script><script src="/js/script.js"></script>