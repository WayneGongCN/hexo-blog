<!DOCTYPE html><html lang="en"><title>Javascript 并发模型与事件循环 - OS</title><meta charset="utf-8"><meta name="description"content="Javascript 并发模型与事件循环"><meta name="keywords"><meta name="subtitle"content="Code &amp; Life"><meta name="author"content="zowiegong"><meta name="language"content="zh-CN"><meta name="timezone"content="Asia/Shanghai"><meta name="viewport"content="width=device-width,initial-scale=1"><link href="/manifest.json"rel="manifest"><link href="/atom.xml"rel="alternate"type="application/atom+xml"><link href="/images/favicon.ico"rel="shortcut icon"type="image/x-icon"><link href="/css/style.css"rel="stylesheet"><link href="/css/post.css"rel="stylesheet"><meta name="generator"content="Hexo 4.2.0"><header id="header-container"><h1 id="blog-title"><a href="/">OS</a></h1><nav><ul class="menu-list"><li class="menu-list-item"><a href="/categories"class="menu-name">categories</a><li class="menu-list-item"><a href="/tags"class="menu-name">tags</a><li class="menu-list-item"><a href="/about"class="menu-name">about</a></ul></nav></header><article class="main"><h1 id="post-title">Javascript 并发模型与事件循环</h1><div class="post-info"><time class="post-date">2018-10-09</time><ul class="tag-list"><li class="tag-item"><a href="/tags/javascript/"class="tag-name">#javascript</a></ul></div><section class="markdown-body"><p>Javascript 作为单线程的脚本语言，通过事件循环机制（event-loop）实现其 “非阻塞” 的特性。<h2><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A6%82%E5%BF%B5"class="anchor"aria-hidden="true"id="user-content-运行时概念"><span class="octicon octicon-link"aria-hidden="true"></span></a>运行时概念</h2><h3><a href="#%E6%A0%88"class="anchor"aria-hidden="true"id="user-content-栈"><span class="octicon octicon-link"aria-hidden="true"></span></a>栈</h3><p>函数的调用会形成栈帧，最外层函数的栈帧被压入栈的最底层，当最外层的函数返回后，栈就空了。<h3><a href="#%E5%A0%86"class="anchor"aria-hidden="true"id="user-content-堆"><span class="octicon octicon-link"aria-hidden="true"></span></a>堆</h3><p>堆表示一个大部分非结构化的内存区域，对象被分配在堆中。<h3><a href="#%E9%98%9F%E5%88%97"class="anchor"aria-hidden="true"id="user-content-队列"><span class="octicon octicon-link"aria-hidden="true"></span></a>队列</h3><p>JavaScript 运行时包含了一个待处理的消息队列。队列中的每个消息都有对应的处理函数。<h2><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"class="anchor"aria-hidden="true"id="user-content-事件循环"><span class="octicon octicon-link"aria-hidden="true"></span></a>事件循环</h2><p>事件循环的实现简单来说如下：<div class="highlight highlight-source-js"><pre><span class="pl-k">while</span> (<span class="pl-smi">queue</span>.<span class="pl-en">waitForMessage</span>()) {
    <span class="pl-smi">queue</span>.<span class="pl-en">processNextMessage</span>();
}</pre></div><h3><a href="#%E6%89%A7%E8%A1%8C%E8%87%B3%E5%AE%8C%E6%88%90"class="anchor"aria-hidden="true"id="user-content-执行至完成"><span class="octicon octicon-link"aria-hidden="true"></span></a>执行至完成</h3><p>每一个消息完整的执行后，其它消息才会被执行。<h3><a href="#%E6%B7%BB%E5%8A%A0%E6%B6%88%E6%81%AF"class="anchor"aria-hidden="true"id="user-content-添加消息"><span class="octicon octicon-link"aria-hidden="true"></span></a>添加消息</h3><p>当一个事件出现且有一个事件监听器被绑定时，消息会被随时添加。<p>如果没有事件监听器，事件会丢失。<p>调用<code>setTimeout</code>函数会在一个时间段过去后在队列中添加一个消息。<p>这个时间段作为函数的第二个参数被传入,时间参数的值代表了消息被实际加入到队列的最小延迟时间。<p>如果队列中没有其它消息，消息会被马上处理。<h3><a href="#%E9%9B%B6%E5%BB%B6%E8%BF%9F"class="anchor"aria-hidden="true"id="user-content-零延迟"><span class="octicon octicon-link"aria-hidden="true"></span></a>零延迟</h3><p>在零延迟调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowTimers/setTimeout"target="_blank"rel="nofollow noopener"><code>setTimeout</code></a>时，其并不是过了给定的时间间隔后就马上执行回调函数。<p>其等待的时间基于队列里正在等待的消息数量。<h3><a href="#%E5%A4%9A%E4%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1"class="anchor"aria-hidden="true"id="user-content-多个运行时互相通信"><span class="octicon octicon-link"aria-hidden="true"></span></a>多个运行时互相通信</h3><p>一个 web worker 或者一个跨域的<code>iframe</code>都有自己的栈，堆和消息队列。<p>两个不同的运行时只能通过<code>postMessage</code>方法进行通信。<p>如果后者侦听到<code>message</code>事件，则此方法会向其他运行时添加消息。<h2><a href="#%E5%85%B6%E4%BB%96"class="anchor"aria-hidden="true"id="user-content-其他"><span class="octicon octicon-link"aria-hidden="true"></span></a>其他</h2><h3><a href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E6%AD%BB%E5%BE%AA%E7%8E%AF"class="anchor"aria-hidden="true"id="user-content-阻塞与死循环"><span class="octicon octicon-link"aria-hidden="true"></span></a>阻塞与死循环</h3><p>由于 “执行至完成” 的特性，当一个消息需要太长时间才能完成，如遇到了死循环，Web应用无法处理用户的交互，例如点击或滚动。<p>Q：这时 Js 的执行状态是否是阻塞的？ 是否与 JavaScript 非阻塞的特性矛盾？<p>A：不矛盾。阻塞是等待响应，代码处于停止状态。死循环是执行重复的代码导致耗尽计算机资源。</section></article><footer class="footer-container"><section>Copyright &copy; 2020&nbsp;<a href="mailto:zowiegong@gmail.com">zowiegong</a>&nbsp;Powered by&nbsp;<a href="https://github.com/hexojs/hexo"target="_blank"rel="noopener noreferrer">Hexo</a>&nbsp;Theme by&nbsp;<a href="https://github.com/zowiegong/hexo-theme-os"target="_blank"rel="noopener noreferrer">OS.</a><br><a href="https://github.com/zowiegong/hexo-blog/edit/master/source/_posts/Javascript eventloop.md"target="_blank">Edit source file</a></section></footer><div class="hover-pointer"id="scroll-to-top-container"><svg class="hover-fill"height="3rem "id="scroll-to-top-btn"version="1.1"viewBox="0 0 1024 1024"width="3rem"><path d="M825.568 555.328l-287.392-289.28C531.808 259.648 523.488 256.576 515.2 256.64 514.08 256.544 513.12 256 512 256c-4.672 0-9.024 1.088-13.024 2.88-4.032 1.536-7.872 3.872-11.136 7.136l-259.328 258.88c-12.512 12.48-12.544 32.736-0.032 45.248 6.24 6.272 14.432 9.408 22.656 9.408 8.192 0 16.352-3.136 22.624-9.344L480 364.288 480 928c0 17.696 14.336 32 32 32s32-14.304 32-32L544 362.72l236.192 237.728c6.24 6.272 14.496 9.44 22.688 9.44s16.32-3.104 22.56-9.312C838.016 588.128 838.048 567.84 825.568 555.328z"p-id="1100"></path><path d="M864 192 160 192C142.336 192 128 177.664 128 160s14.336-32 32-32l704 0c17.696 0 32 14.336 32 32S881.696 192 864 192z"p-id="1101"></path></svg></div><script>let pluginsConfig = JSON.parse('{"googleAnalytics":"UA-121105508-1","scrollToTop":true,"scrollSmooth":false,"comments":{"enable":true,"repo":"zowiegong/hexo-blog"}}')</script><script>pluginsConfig.comments.enable = true</script><script src="/js/script.js"></script>