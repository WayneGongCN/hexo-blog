<!DOCTYPE html><html lang="en"><title>Javascript 五子棋 - OS</title><meta charset="utf-8"><meta name="description"content="Javascript 五子棋"><meta name="keywords"><meta name="subtitle"content="Code &amp; Life"><meta name="author"content="zowiegong"><meta name="language"content="zh-CN"><meta name="timezone"content="Asia/Shanghai"><meta name="viewport"content="width=device-width,initial-scale=1"><link href="/manifest.json"rel="manifest"><link href="/atom.xml"rel="alternate"type="application/atom+xml"><link href="/images/favicon.ico"rel="shortcut icon"type="image/x-icon"><link href="/css/style.css"rel="stylesheet"><link href="/css/post.css"rel="stylesheet"><meta name="generator"content="Hexo 4.2.0"><header id="header-container"><h1 id="blog-title"><a href="/">OS</a></h1><nav><ul class="menu-list"><li class="menu-list-item"><a href="/categories"class="menu-name">categories</a><li class="menu-list-item"><a href="/tags"class="menu-name">tags</a><li class="menu-list-item"><a href="/about"class="menu-name">about</a></ul></nav></header><article class="main"><h1 id="post-title">Javascript 五子棋</h1><div class="post-info"><time class="post-date">2017-09-21</time><ul class="tag-list"><li class="tag-item"><a href="/tags/javascript/"class="tag-name">#javascript</a></ul></div><section class="markdown-body"><h2><a href="#%E7%AE%80%E5%8D%95%E7%9A%84-javascript-%E4%BA%94%E5%AD%90%E6%A3%8B-demo"class="anchor"aria-hidden="true"id="user-content-简单的-javascript-五子棋-demo"><span class="octicon octicon-link"aria-hidden="true"></span></a>简单的 Javascript 五子棋 Demo</h2><hr><p>Dome:<a href="https://zowiegong.github.io/javascript-five-chess/"target="_blank"rel="nofollow noopener">https://zowiegong.github.io/javascript-five-chess/</a><p>Repo:<a href="https://github.com/helloAwei/javascript-five-chess"target="_blank"rel="noopener">https://github.com/helloAwei/javascript-five-chess</a><h3><a href="#%E7%AE%80%E4%BB%8B"class="anchor"aria-hidden="true"id="user-content-简介"><span class="octicon octicon-link"aria-hidden="true"></span></a>简介</h3><ul><li>实现胜负判断，并给出赢棋提示。<li>界面用 DOM 实现<li>实现悔棋</ul><p>前端用<a href="http://knockoutjs.com/"target="_blank"rel="nofollow noopener">Knockout</a>做双向绑定。<p>思路：用一个二维数组生成棋盘，对格子添加点击事件，用一个布尔值进行切换黑白轮流落子，落子后对当前棋子进行胜负判断 ...<h3><a href="#%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"class="anchor"aria-hidden="true"id="user-content-生成二维数组"><span class="octicon octicon-link"aria-hidden="true"></span></a>生成二维数组</h3><div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">GeneratorList</span>() {
    <span class="pl-k">let</span> array <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Array</span>(<span class="pl-c1">ROW</span>).<span class="pl-en">fill</span>(<span class="pl-c1">null</span>);

    <span class="pl-c"><span class="pl-c">//</span>生成二维数组</span>
    <span class="pl-k">let</span> result <span class="pl-k">=</span> <span class="pl-smi">array</span>.<span class="pl-en">map</span>((<span class="pl-smi">value</span>, <span class="pl-smi">y</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-k">return</span> <span class="pl-smi">array</span>.<span class="pl-en">map</span>((<span class="pl-smi">value</span>, <span class="pl-smi">x</span>) <span class="pl-k">=&gt;</span> {
            <span class="pl-k">return</span> {
                hasChess<span class="pl-k">:</span> <span class="pl-smi">ko</span>.<span class="pl-en">observable</span>(<span class="pl-c1">false</span>),
                value<span class="pl-k">:</span> <span class="pl-smi">ko</span>.<span class="pl-en">observable</span>(<span class="pl-c1">null</span>),
                x<span class="pl-k">:</span> x,
                y<span class="pl-k">:</span> y
            }
        });
    });
    <span class="pl-k">return</span> result;
}</pre></div><p>生成一个 15*15 的二维数组，<code>List[y][x]</code>能取到对应格子的状态。 初始的状态为：<div class="highlight highlight-source-js"><pre>{
    hasChess<span class="pl-k">:</span> <span class="pl-smi">ko</span>.<span class="pl-en">observable</span>(<span class="pl-c1">false</span>),    <span class="pl-c"><span class="pl-c">//</span>是否有棋子</span>
    value<span class="pl-k">:</span> <span class="pl-smi">ko</span>.<span class="pl-en">observable</span>(<span class="pl-c1">null</span>),        <span class="pl-c"><span class="pl-c">//</span>棋子的值（黑或白）</span>
    x<span class="pl-k">:</span> x,                              <span class="pl-c"><span class="pl-c">//</span>坐标</span>
    y<span class="pl-k">:</span> y
}</pre></div><p>这里没有单独去定义一个棋子类，直接用的字面量形式。<h3><a href="#%E8%90%BD%E5%AD%90"class="anchor"aria-hidden="true"id="user-content-落子"><span class="octicon octicon-link"aria-hidden="true"></span></a>落子</h3><div class="highlight highlight-source-js"><pre><span class="pl-smi">ViewModel</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">down</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">data</span>) {
    <span class="pl-k">if</span> (<span class="pl-smi">data</span>.<span class="pl-en">hasChess</span>()) <span class="pl-k">return</span>;
    <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-en">winer</span>()) <span class="pl-c1">this</span>.<span class="pl-en">rePlay</span>();
    <span class="pl-c"><span class="pl-c">//</span> change</span>
    <span class="pl-smi">data</span>.<span class="pl-en">hasChess</span>(<span class="pl-c1">true</span>);
    <span class="pl-smi">data</span>.<span class="pl-c1">value</span>(<span class="pl-c1">this</span>.<span class="pl-en">isBlack</span>() <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span>X<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>O<span class="pl-pds">'</span></span>);

    <span class="pl-c"><span class="pl-c">//</span> add history</span>
    <span class="pl-c1">this</span>.<span class="pl-c1">history</span>.<span class="pl-c1">push</span>({
        x<span class="pl-k">:</span> <span class="pl-smi">data</span>.<span class="pl-c1">x</span>,
        y<span class="pl-k">:</span> <span class="pl-smi">data</span>.<span class="pl-c1">y</span>
    });

    <span class="pl-c"><span class="pl-c">//</span>判断输赢</span>
    <span class="pl-c1">this</span>.<span class="pl-en">referee</span>(data);

    <span class="pl-c"><span class="pl-c">//</span>换手</span>
    <span class="pl-c1">this</span>.<span class="pl-en">isBlack</span>(<span class="pl-k">!</span><span class="pl-c1">this</span>.<span class="pl-en">isBlack</span>());
}</pre></div><p>落子前进行判断，落子，然后添加一条历史记录，判断输赢，换手。。。<h3><a href="#%E5%88%A4%E6%96%AD%E8%BE%93%E8%B5%A2%E7%9A%84%E7%AE%97%E6%B3%95"class="anchor"aria-hidden="true"id="user-content-判断输赢的算法"><span class="octicon octicon-link"aria-hidden="true"></span></a>判断输赢的算法</h3><div class="highlight highlight-source-js"><pre><span class="pl-smi">ViewModel</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">referee</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">item</span>) {
    <span class="pl-c"><span class="pl-c">//</span>四个方向</span>
    <span class="pl-k">let</span> change <span class="pl-k">=</span> [[<span class="pl-c1">0</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>], [<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>], [<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>], [<span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">1</span>]];

    <span class="pl-smi">change</span>.<span class="pl-c1">forEach</span>(<span class="pl-smi">c</span> <span class="pl-k">=&gt;</span> {
        <span class="pl-c"><span class="pl-c">//</span>朝某个方向递归</span>
        <span class="pl-c1">this</span>.<span class="pl-c1">test</span>(item, c);

        <span class="pl-c"><span class="pl-c">//</span>不足五连珠朝反方向递归</span>
        <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-smi">lineTotal</span> <span class="pl-k">&lt;=</span> <span class="pl-c1">4</span>) {
            <span class="pl-c"><span class="pl-c">//</span>反方向</span>
            <span class="pl-k">let</span> reveis <span class="pl-k">=</span> <span class="pl-smi">c</span>.<span class="pl-en">map</span>(<span class="pl-smi">x</span> <span class="pl-k">=&gt;</span> {
                <span class="pl-k">return</span> x <span class="pl-k">*</span> <span class="pl-k">-</span><span class="pl-c1">1</span>;
            });

            <span class="pl-c1">this</span>.<span class="pl-c1">test</span>(item, reveis)
            <span class="pl-c1">this</span>.<span class="pl-smi">lineTotal</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
        };
    })
}</pre></div><p>判断胜负需要检查一个棋子的八个方向上有无五连珠的情况。<a href="https://camo.githubusercontent.com/2495a5d1f38973b9cb8d08f98ef829cbef49b30b/687474703a2f2f6f666c39376c3861762e626b742e636c6f7564646e2e636f6d2f31372d392d32322f36393932393835392e6a7067"target="_blank"rel="nofollow"><img alt=""data-canonical-src="http://ofl97l8av.bkt.clouddn.com/17-9-22/69929859.jpg"src="https://camo.githubusercontent.com/2495a5d1f38973b9cb8d08f98ef829cbef49b30b/687474703a2f2f6f666c39376c3861762e626b742e636c6f7564646e2e636f6d2f31372d392d32322f36393932393835392e6a7067"style="max-width:100%;"></a><p><code>change</code>是一个保存了四个检查方向的二维数组。 在朝某个方向检查完之后然后反向的检查，这样能够将八个方向缩减为四个。 例： 1、2、3、4 反向后对应 5、6、7、8<p>如果某个方向不满足五连珠的情况（代码中为&lt;=4，因为检查不包括本身），则向反向的方向进行检查。<p>下面是一个递归检查的方法：<div class="highlight highlight-source-js"><pre><span class="pl-c"><span class="pl-c">//</span>判断连子</span>
<span class="pl-smi">ViewModel</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">test</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">item</span>, <span class="pl-smi">change</span>, <span class="pl-smi">total</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>) {
    <span class="pl-k">let</span> cx <span class="pl-k">=</span> <span class="pl-smi">item</span>.<span class="pl-c1">x</span> <span class="pl-k">+</span> change[<span class="pl-c1">0</span>];
    <span class="pl-k">let</span> cy <span class="pl-k">=</span> <span class="pl-smi">item</span>.<span class="pl-c1">y</span> <span class="pl-k">+</span> change[<span class="pl-c1">1</span>];

    <span class="pl-k">let</span> isInBoard <span class="pl-k">=</span> (cx <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> cx <span class="pl-k">&lt;=</span> <span class="pl-c1">ROW</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>) <span class="pl-k">&amp;&amp;</span> (cy <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> cy <span class="pl-k">&lt;=</span> <span class="pl-c1">ROW</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>);
    <span class="pl-k">let</span> cItem <span class="pl-k">=</span> isInBoard <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">this</span>.<span class="pl-en">allBoxs</span>()[cy][cx];
    <span class="pl-k">let</span> isNull <span class="pl-k">=</span> cItem <span class="pl-k">!==</span> <span class="pl-c1">null</span>;

    <span class="pl-k">if</span> (isNull <span class="pl-k">&amp;&amp;</span>
        isInBoard <span class="pl-k">&amp;&amp;</span>
        <span class="pl-smi">item</span>.<span class="pl-c1">value</span>() <span class="pl-k">===</span> <span class="pl-smi">cItem</span>.<span class="pl-c1">value</span>()
    ) {
        total <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
        <span class="pl-c"><span class="pl-c">//</span>递归</span>
        <span class="pl-c1">this</span>.<span class="pl-c1">test</span>(cItem, change, total);
    } <span class="pl-k">else</span> {
        <span class="pl-c"><span class="pl-c">//</span>跳出</span>
        <span class="pl-c1">this</span>.<span class="pl-smi">lineTotal</span> <span class="pl-k">+=</span> total;
    }

    <span class="pl-c"><span class="pl-c">//</span>win</span>
    <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-smi">lineTotal</span> <span class="pl-k">&gt;=</span> <span class="pl-c1">4</span>) {
        <span class="pl-c1">this</span>.<span class="pl-en">win</span>();
    };
}</pre></div><p>直到下一个棋子不是与本身同类型的棋子便跳出递归，同时将<code>total</code>返回。<p>完。</section></article><footer class="footer-container"><section>Copyright &copy; 2020&nbsp;<a href="mailto:zowiegong@gmail.com">zowiegong</a>&nbsp;Powered by&nbsp;<a href="https://github.com/hexojs/hexo"target="_blank"rel="noopener noreferrer">Hexo</a>&nbsp;Theme by&nbsp;<a href="https://github.com/zowiegong/hexo-theme-os"target="_blank"rel="noopener noreferrer">OS.</a><br><a href="https://github.com/zowiegong/hexo-blog/edit/master/source/_posts/Javascript 5chess.md"target="_blank">Edit source file</a></section></footer><div class="hover-pointer"id="scroll-to-top-container"><svg class="hover-fill"height="3rem "id="scroll-to-top-btn"version="1.1"viewBox="0 0 1024 1024"width="3rem"><path d="M825.568 555.328l-287.392-289.28C531.808 259.648 523.488 256.576 515.2 256.64 514.08 256.544 513.12 256 512 256c-4.672 0-9.024 1.088-13.024 2.88-4.032 1.536-7.872 3.872-11.136 7.136l-259.328 258.88c-12.512 12.48-12.544 32.736-0.032 45.248 6.24 6.272 14.432 9.408 22.656 9.408 8.192 0 16.352-3.136 22.624-9.344L480 364.288 480 928c0 17.696 14.336 32 32 32s32-14.304 32-32L544 362.72l236.192 237.728c6.24 6.272 14.496 9.44 22.688 9.44s16.32-3.104 22.56-9.312C838.016 588.128 838.048 567.84 825.568 555.328z"p-id="1100"></path><path d="M864 192 160 192C142.336 192 128 177.664 128 160s14.336-32 32-32l704 0c17.696 0 32 14.336 32 32S881.696 192 864 192z"p-id="1101"></path></svg></div><script>let pluginsConfig = JSON.parse('{"googleAnalytics":"UA-121105508-1","scrollToTop":true,"scrollSmooth":false,"comments":{"enable":true,"repo":"zowiegong/hexo-blog"}}')</script><script>pluginsConfig.comments.enable = true</script><script src="/js/script.js"></script>