<!DOCTYPE html><html lang="en"><title>尾调用优化 - OS</title><meta charset="utf-8"><meta name="description"content="尾调用优化"><meta name="keywords"><meta name="subtitle"content="Code &amp; Life"><meta name="author"content="zowiegong"><meta name="language"content="zh-CN"><meta name="timezone"content="Asia/Shanghai"><meta name="viewport"content="width=device-width,initial-scale=1"><link href="/manifest.json"rel="manifest"><link href="/atom.xml"rel="alternate"type="application/atom+xml"><link href="/images/favicon.ico"rel="shortcut icon"type="image/x-icon"><link href="/css/style.css"rel="stylesheet"><link href="/css/post.css"rel="stylesheet"><meta name="generator"content="Hexo 4.2.0"><header id="header-container"><h1 id="blog-title"><a href="/">OS</a></h1><nav><ul class="menu-list"><li class="menu-list-item"><a href="/categories"class="menu-name">categories</a><li class="menu-list-item"><a href="/tags"class="menu-name">tags</a><li class="menu-list-item"><a href="/about"class="menu-name">about</a></ul></nav></header><article class="main"><h1 id="post-title">尾调用优化</h1><div class="post-info"><time class="post-date">2018-10-10</time></div><section class="markdown-body"><p>当函数的调用层数非常多时，需要同时保存成千上百个调用记录，调用栈会消耗不少内存，甚容易导致<a href="https://zh.wikipedia.org/wiki/%E6%A0%88%E6%BA%A2%E5%87%BA"target="_blank"rel="nofollow noopener">栈溢出</a>。<p>尾调用的<a href="https://zh.wikipedia.org/wiki/%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A"target="_blank"rel="nofollow noopener">调用栈</a>则特别易于优化，从而可减少内存空间的使用，也能提高运行速度。<h2><a href="#%E5%B0%BE%E8%B0%83%E7%94%A8"class="anchor"aria-hidden="true"id="user-content-尾调用"><span class="octicon octicon-link"aria-hidden="true"></span></a>尾调用</h2><p><strong>尾调用</strong>(tail call) 指的是一个函数的最后一条语句是一个返回调用函数的语句。<div class="highlight highlight-source-js"><pre><span class="pl-c"><span class="pl-c">//</span> 属于尾调用</span>
<span class="pl-k">function</span> <span class="pl-en">bar</span>(<span class="pl-smi">data</span>) {
    <span class="pl-k">if</span> ( <span class="pl-en">a</span>(data) ) {
        <span class="pl-k">return</span> <span class="pl-en">b</span>(data);
    }
    <span class="pl-k">return</span> <span class="pl-en">c</span>(data);
}

<span class="pl-k">function</span> <span class="pl-en">foo</span>(<span class="pl-smi">data</span>) {
    <span class="pl-en">a</span>(data);
    <span class="pl-k">return</span> <span class="pl-en">b</span>(data);
}</pre></div><div class="highlight highlight-source-js"><pre><span class="pl-c"><span class="pl-c">//</span> 不属于尾调用</span>
<span class="pl-k">function</span> <span class="pl-en">foo1</span>(<span class="pl-smi">data</span>) {
    <span class="pl-k">return</span> <span class="pl-en">a</span>(data) <span class="pl-k">+</span> <span class="pl-c1">1</span>;
}

<span class="pl-k">function</span> <span class="pl-en">foo2</span>(<span class="pl-smi">data</span>) {
    <span class="pl-k">var</span> ret <span class="pl-k">=</span> <span class="pl-en">a</span>(data);
    <span class="pl-k">return</span> ret;
}</pre></div><h3><a href="#%E8%B0%83%E7%94%A8%E6%A0%88"class="anchor"aria-hidden="true"id="user-content-调用栈"><span class="octicon octicon-link"aria-hidden="true"></span></a>调用栈</h3><p>当一个函数被调用时，函数的调用位置与返回位置被保存在调用栈中，调用结束时才能带着返回值回到该位置。<p>在尾调用这种特殊情形中，计算机理论上可以不需要记住尾调用的位置而从被调用的函数直接带着返回值返回调用函数的返回位置。<p>尾调用消除即是在不改变当前调用栈（也不添加新的返回位置）的情况下跳到新函数的一种优化。<h2><a href="#%E5%B0%BE%E9%80%92%E5%BD%92"class="anchor"aria-hidden="true"id="user-content-尾递归"><span class="octicon octicon-link"aria-hidden="true"></span></a>尾递归</h2><p>在尾调用的情况下<strong>调用自身</strong>的特殊尾调用称为<strong>尾递归</strong>。<h3><a href="#%E4%BC%98%E5%8C%96%E5%B0%BE%E9%80%92%E5%BD%92%E7%9A%84%E5%88%86%E6%9E%90"class="anchor"aria-hidden="true"id="user-content-优化尾递归的分析"><span class="octicon octicon-link"aria-hidden="true"></span></a>优化尾递归的分析</h3><p>由于函数自身调用次数很多，递归层级很深，尾递归优化则使原本 O(n) 的调用栈空间只需要 O(1)。<p>"尾调用优化"对递归操作意义重大，ES6 中明确规定，所有 ECMAScript 的实现，都必须部署"尾调用优化"。<p>所以在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。<p>现有<code>recsum</code>函数如下：<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">recsum</span> (<span class="pl-smi">num</span>) {
    <span class="pl-k">if</span> (num <span class="pl-k">===</span> <span class="pl-c1">1</span>) <span class="pl-k">return</span> <span class="pl-c1">1</span>
    <span class="pl-k">else</span> <span class="pl-k">return</span> num <span class="pl-k">+</span> <span class="pl-en">recsum</span>(num <span class="pl-k">-</span> <span class="pl-c1">1</span>)
}</pre></div><p>调用<code>recsum(5)</code>为例:<pre><code>recsum(5)
5 + recsum(4)
5 + (4 + recsum(3))
5 + (4 + (3 + recsum(2)))
5 + (4 + (3 + (2 + recsum(1))))
5 + (4 + (3 + (2 + 1)))
5 + (4 + (3 + 3))
5 + (4 + 6)
5 + 10
15
</code></pre><p>堆栈从左到右，增加到一个峰值后再计算从右到左缩小。<p>修改以上代码，可以成为尾递归：<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">tailrecsum</span> (<span class="pl-smi">num</span>, <span class="pl-smi">running_total</span><span class="pl-k">=</span><span class="pl-c1">0</span>) {
    <span class="pl-k">if</span> (num <span class="pl-k">===</span> <span class="pl-c1">0</span>) <span class="pl-k">return</span> running_total
    <span class="pl-k">else</span> <span class="pl-k">return</span> <span class="pl-en">tailrecsum</span>(num <span class="pl-k">-</span> <span class="pl-c1">1</span>, running_total <span class="pl-k">+</span> num)
}</pre></div><p>后者尾递归对内存的消耗<pre><code>tailrecsum(5, 0) 
tailrecsum(4, 5) 
tailrecsum(3, 9)
tailrecsum(2, 12) 
tailrecsum(1, 14) 
tailrecsum(0, 15) 
15
</code></pre><h3><a href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E4%BF%AE%E6%94%B9"class="anchor"aria-hidden="true"id="user-content-递归函数的修改"><span class="octicon octicon-link"aria-hidden="true"></span></a>递归函数的修改</h3><p>由于要实现尾调用优化，函数的调用栈不在增加所以无法保持函数的局部变量，需要将局部变量以参数的形式传入，如上面的例子，来实现尾调用的优化。<p>递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。<p>对于其他支持"尾调用优化"的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</section></article><footer class="footer-container"><section>Copyright &copy; 2020&nbsp;<a href="mailto:zowiegong@gmail.com">zowiegong</a>&nbsp;Powered by&nbsp;<a href="https://github.com/hexojs/hexo"target="_blank"rel="noopener noreferrer">Hexo</a>&nbsp;Theme by&nbsp;<a href="https://github.com/zowiegong/hexo-theme-os"target="_blank"rel="noopener noreferrer">OS.</a><br><a href="https://github.com/zowiegong/hexo-blog/edit/master/source/_posts/Tail recursion.md"target="_blank">Edit source file</a></section></footer><div class="hover-pointer"id="scroll-to-top-container"><svg class="hover-fill"height="3rem "id="scroll-to-top-btn"version="1.1"viewBox="0 0 1024 1024"width="3rem"><path d="M825.568 555.328l-287.392-289.28C531.808 259.648 523.488 256.576 515.2 256.64 514.08 256.544 513.12 256 512 256c-4.672 0-9.024 1.088-13.024 2.88-4.032 1.536-7.872 3.872-11.136 7.136l-259.328 258.88c-12.512 12.48-12.544 32.736-0.032 45.248 6.24 6.272 14.432 9.408 22.656 9.408 8.192 0 16.352-3.136 22.624-9.344L480 364.288 480 928c0 17.696 14.336 32 32 32s32-14.304 32-32L544 362.72l236.192 237.728c6.24 6.272 14.496 9.44 22.688 9.44s16.32-3.104 22.56-9.312C838.016 588.128 838.048 567.84 825.568 555.328z"p-id="1100"></path><path d="M864 192 160 192C142.336 192 128 177.664 128 160s14.336-32 32-32l704 0c17.696 0 32 14.336 32 32S881.696 192 864 192z"p-id="1101"></path></svg></div><script>let pluginsConfig = JSON.parse('{"googleAnalytics":"UA-121105508-1","scrollToTop":true,"scrollSmooth":false,"comments":{"enable":true,"repo":"zowiegong/hexo-blog"}}')</script><script>pluginsConfig.comments.enable = true</script><script src="/js/script.js"></script>